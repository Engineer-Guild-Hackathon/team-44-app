## **AI学習サポート機能 開発仕様書 (MVP)**

### **1. はじめに**

#### **1.1 本ドキュメントの目的**
本ドキュメントは、「AI学習サポート機能」のMVP（Minimum Viable Product）開発に必要な全ての技術情報を定義するものです。製品要求仕様（PRD）の目的・スコープを継承しつつ、具体的な環境構築、プロジェクト構成、コーディング規約、デプロイ手順までを網羅し、開発チームがスムーズに開発に着手できることを目的とします。

#### **1.2 MVPのスコープ**
*   **目的:** AIとの対話を通じて、ユーザーが「自力で解けた」という達成感を得られるコア機能を提供する。
*   **対象機能:**
    *   テキストによる問題入力
    *   AIによるインタラクティブなヒント提供
    *   シンプルな問題における小問題への分解
    *   対話ログの表示・保存
*   **対象外:** 写真での問題入力、学習記録の自動登録（フェーズ4連携）、高度なパーソナライズ機能。
i
### **2. 技術スタックとツール**

| 領域 | 技術・ツール | バージョン（推奨） |
| :--- | :--- | :--- |
| **フロントエンド** | Next.js, React, TypeScript | Next.js 14+, React 18+ |
| **バックエンド** | Node.js, TypeScript, Express | Node.js 20+ |
| **インフラ** | Vercel, Firebase (Authentication, Firestore, Functions) | - |
| **言語** | TypeScript | 5.x |
| **パッケージ管理** | npm | 10.x |
| **UIライブラリ** | Shadcn/ui (推奨) | - |
| **状態管理** | Zustand (推奨) | 4.x |
| **LLM API** | Google Gemini API (or OpenAI API) | - |

### **3. 環境構築ガイド**

#### **3.1 前提条件**
*   [Node.js](https://nodejs.org/) (v20以上) と npm がインストールされていること。
*   [Git](https://git-scm.com/) がインストールされていること。
*   GoogleアカウントとFirebaseプロジェクトを作成済みであること。
*   GitHubアカウントとVercelアカウントを作成済みであること。

#### **3.2 Firebase プロジェクトのセットアップ**
1.  **Firebase CLIのインストールとログイン**
    ```bash
    npm install -g firebase-tools
    firebase login
    ```
2.  **プロジェクトの初期化**
    *   ローカルにプロジェクトディレクトリを作成し、その中で以下のコマンドを実行します。
    ```bash
    # 対話形式で設定を進める
    firebase init

    # 選択する機能:
    # ◯ Firestore: Firestore security rules and indexes files
    # ◯ Functions: Configure a new functions directory and related files
    # ◯ Hosting: Configure files for Firebase Hosting and (optionally) set up GitHub Action deploys (※Vercelを使うが念のため)
    # ◯ Emulators: Configure local emulators for Firebase features
    ```
3.  **Firebaseコンソールでの設定**
    *   **Authentication:** 「Sign-in method」タブで「メール/パスワード」を有効にします。
    *   **Firestore:** 「データベースの作成」からテストモードまたは本番環境モードでデータベースを初期化します。

#### **3.3 LLM APIキーの取得**
*   **Gemini API の場合:**
    1.  [Google AI Studio](https://aistudio.google.com/) にアクセスします。
    2.  「Get API key」をクリックし、新しいAPIキーを作成します。
    3.  作成したAPIキーを安全な場所に保管します。
*   **OpenAI API の場合:**
    1.  [OpenAI Platform](https://platform.openai.com/) にアクセスし、ログインします。
    2.  API keysページから「Create new secret key」をクリックします。
    3.  作成したAPIキーを安全な場所に保管します。

#### **3.4 環境変数の設定**
*   プロジェクトのルートに、バックエンド用とフロントエンド用の `.env` ファイルを作成します。

*   **バックエンド (`functions/.env`)**
    ```
    # 使用するLLMの指定 (gemini or openai)
    LLM_PROVIDER=gemini

    # 各LLMのAPIキー
    GEMINI_API_KEY="your_gemini_api_key_here"
    OPENAI_API_KEY="your_openai_api_key_here"
    ```

*   **フロントエンド (`.env.local`)**
    ```
    # Firebaseプロジェクトの設定値 (Firebaseコンソールのプロジェクト設定からコピー)
    NEXT_PUBLIC_FIREBASE_API_KEY="your_firebase_api_key"
    NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="your_project_id.firebaseapp.com"
    NEXT_PUBLIC_FIREBASE_PROJECT_ID="your_project_id"
    NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET="your_project_id.appspot.com"
    NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID="your_sender_id"
    NEXT_PUBLIC_FIREBASE_APP_ID="your_app_id"

    # バックエンドAPIのエンドポイント
    NEXT_PUBLIC_API_BASE_URL="http://127.0.0.1:5001/your_project_id/us-central1/api"
    ```
    *`NEXT_PUBLIC_API_BASE_URL` はローカル開発用のURLです。本番環境ではデプロイしたCloud FunctionsのURLに設定します。*

### **4. プロジェクト構成**

フロントエンドとバックエンドを一つのリポジトリで管理するモノレポ構成を推奨します。

```
/
├── .env.local                  # FE 環境変数
├── .firebaserc                 # Firebase プロジェクト設定
├── firebase.json               # Firebase デプロイ設定
├── package.json                # プロジェクト全体の依存関係 (lerna/nxなどで管理)
│
├── functions/                  # バックエンド (Firebase Functions)
│   ├── src/
│   │   ├── controllers/        # リクエスト/レスポンス処理
│   │   │   └── chatController.ts
│   │   ├── services/           # ビジネスロジック
│   │   │   ├── chatService.ts
│   │   │   └── llm/            # LLM関連ロジック (切替可能に)
│   │   │       ├── llmInterface.ts  # LLMプロバイダのインターフェース
│   │   │       ├── geminiProvider.ts # Gemini実装
│   │   │       ├── openaiProvider.ts # OpenAI実装
│   │   │       └── llmFactory.ts    # 環境変数に応じてプロバイダを切り替えるファクトリ
│   │   ├── models/             # データモデル (型定義)
│   │   │   └── types.ts
│   │   └── index.ts            # Cloud Functionsエントリーポイント
│   ├── .env                    # BE 環境変数
│   ├── package.json
│   └── tsconfig.json
│
└── web/                        # フロントエンド (Next.js)
    ├── app/
    │   ├── page.tsx             # トップページ (Home コンポーネントを import)
    │   ├── chat/
    │   │   ├── page.tsx        # AI対話画面 (Chat コンポーネントを import)
    │   │   ├── chat.tsx        # AI対話画面のコンポーネント
    │   │   └── [sessionId]/
    │   │       ├── page.tsx    # 動的セッション画面 (Session コンポーネントを import)
    │   │       └── session.tsx # 動的セッション画面のコンポーネント
    │   ├── auth/
    │   │   ├── page.tsx        # 認証関連ページ (Auth コンポーネントを import)
    │   │   └── auth.tsx        # 認証関連ページのコンポーネント
    │   └── layout.tsx
    ├── components/
    │   ├── ui/                 # Shadcn/uiコンポーネント
    │   └── common/
    │       ├── ChatView.tsx
    │       └── MessageInput.tsx
    ├── hooks/
    │   └── useAuth.ts          # 認証状態を管理するカスタムフック
    ├── lib/
    │   ├── firebase.ts         # Firebaseクライアント初期化
    │   └── apiClient.ts        # バックエンドAPIクライアント
    ├── store/
    │   └── chatStore.ts        # Zustandストア (チャット状態管理)
    ├── package.json
    └── tsconfig.json
```

### **5. バックエンド詳細設計 (Firebase Functions)**

#### **5.1 LLMの抽象化と切り替え (llmService)**
将来的にLLMを容易に切り替えられるよう、インターフェースを定義し、ファクトリパターンで実装を注入します。

*   **`functions/src/services/llm/llmInterface.ts`**
    ```typescript
    export interface ChatMessage {
      role: 'user' | 'model';
      parts: { text: string }[];
    }

    export interface LLMProvider {
      generateResponse(history: ChatMessage[], newMessage: string): Promise<string>;
    }
    ```

*   **`functions/src/services/llm/geminiProvider.ts`**
    ```typescript
    import { GoogleGenerativeAI } from "@google/generative-ai";
    import { LLMProvider, ChatMessage } from "./llmInterface";

    export class GeminiProvider implements LLMProvider {
      private genAI: GoogleGenerativeAI;
      constructor(apiKey: string) {
        this.genAI = new GoogleGenerativeAI(apiKey);
      }
      async generateResponse(history: ChatMessage[], newMessage: string): Promise<string> {
        const model = this.genAI.getGenerativeModel({ model: "gemini-pro" });
        // ... (システムプロンプトと対話履歴を結合する処理)
        const result = await model.generateContent(...);
        return result.response.text();
      }
    }
    ```

*   **`functions/src/services/llm/llmFactory.ts`**
    ```typescript
    import { LLMProvider } from "./llmInterface";
    import { GeminiProvider } from "./geminiProvider";
    // import { OpenAIProvider } from "./openaiProvider"; // 必要に応じて実装

    export const getLLMProvider = (): LLMProvider => {
      const providerType = process.env.LLM_PROVIDER;
      switch (providerType) {
        case 'gemini':
          if (!process.env.GEMINI_API_KEY) throw new Error("GEMINI_API_KEY is not set");
          return new GeminiProvider(process.env.GEMINI_API_KEY);
        // case 'openai':
        //   return new OpenAIProvider(process.env.OPENAI_API_KEY);
        default:
          throw new Error(`Unsupported LLM provider: ${providerType}`);
      }
    };
    ```

#### **5.2 APIエンドポイントの実装 (`index.ts`, `chatController.ts`)**
Expressを用いてAPIルーティングを定義します。

*   **`functions/src/index.ts`**
    ```typescript
    import * as functions from "firebase-functions";
    import * as express from "express";
    import * as cors from "cors";
    import { createSession, postMessage } from "./controllers/chatController";

    const app = express();
    app.use(cors({ origin: true })); // Vercelのドメインを許可する設定に要変更
    app.use(express.json());

    // ルーティング
    app.post("/chatSessions", createSession);
    app.post("/chatSessions/:sessionId/messages", postMessage);

    export const api = functions.https.onRequest(app);
    ```

### **6. フロントエンド詳細設計 (Next.js)**

#### **6.1 Firebaseクライアントの初期化**
*   **`web/lib/firebase.ts`**
    ```typescript
    import { initializeApp, getApps } from "firebase/app";
    import { getAuth } from "firebase/auth";
    import { getFirestore } from "firebase/firestore";

    const firebaseConfig = {
      apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
      // ... 他の設定
    };

    const app = getApps().length ? getApps()[0] : initializeApp(firebaseConfig);
    export const auth = getAuth(app);
    export const db = getFirestore(app);
    ```

#### **6.2 APIクライアント**
*   **`web/lib/apiClient.ts`**
    *   `axios` や `fetch` を使用して、バックエンドAPIを呼び出す関数を定義します。認証のために、Firebase Authから取得したIDトークンをリクエストヘッダーに含めます。
    ```typescript
    import axios from "axios";
    import { auth } from "./firebase";

    const apiClient = axios.create({
      baseURL: process.env.NEXT_PUBLIC_API_BASE_URL,
    });

    apiClient.interceptors.request.use(async (config) => {
      const user = auth.currentUser;
      if (user) {
        const token = await user.getIdToken();
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    export default apiClient;
    ```

### **7. デプロイ手順**

#### **7.1 バックエンド (Firebase Functions)**
1.  **環境変数の設定:**
    *   ローカルの `.env` ファイルの内容をFirebaseの環境設定に登録します。
    ```bash
    firebase functions:config:set llm.provider="gemini" \
    llm.gemini_api_key="your_gemini_api_key_here" \
    llm.openai_api_key="your_openai_api_key_here"
    ```
    *コード内で `process.env.LLM_PROVIDER` ではなく `functions.config().llm.provider` のようにアクセスします。*

2.  **デプロイ:**
    ```bash
    # functionsディレクトリに移動して
    cd functions
    npm run build # (TypeScriptのコンパイル)
    # ルートディレクトリに戻って
    cd ..
    firebase deploy --only functions
    ```

#### **7.2 フロントエンド (Vercel)**
1.  **GitHubリポジトリの準備:**
    *   プロジェクトをGitHubにプッシュします。

2.  **Vercelプロジェクトの作成:**
    *   Vercelにログインし、「Add New...」 -> 「Project」を選択します。
    *   作成したGitHubリポジトリをインポートします。
    *   Vercelが自動でNext.jsプロジェクトを認識します。「Root Directory」が `web` になっていることを確認します。

3.  **環境変数の設定:**
    *   プロジェクト設定の「Environment Variables」に、`web/.env.local` の内容を登録します。`NEXT_PUBLIC_API_BASE_URL` は、Firebase Functionsをデプロイした後に得られるURLに書き換えます。

4.  **デプロイ:**
    *   「Deploy」ボタンをクリックします。以降は、GitHubの`main`ブランチにプッシュするたびに自動でデプロイが実行されます。

### **8. 今後のステップ**
本MVPが完成し、ユーザーからのフィードバックが得られた後、以下の機能開発を検討します。
*   **フェーズ4連携:** 学習記録の自動カレンダー登録機能
*   **入力方式の強化:** 写真アップロードによる問題入力
*   **パーソナライズ:** ユーザーの過去の対話履歴に基づいたヒントの最適化
*   **対応教科の拡充:** 数学以外の教科への対応
